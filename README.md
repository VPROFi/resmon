# О проблеме

Ну проект это громко сказано, хотя все возможно...

Начну с вопроса — есть ли в Вашем проекте требования к максимальному расходу памяти, количеству открываемых одновременно файлов и хендлов, загрузки процессора, использования дискового пространства? В случае ответа — нет, смысла что-то читать далее нет. В случае ответа — да, следующий вопрос — а Ваш конечный код (не на этапе разработки и тестирования, а у `каждого` клиента) вообще имеет какие-нибудь рецепторы на эти требования? Если такого нет, то как можно говорить об «ответственности перед клиентом» за свои обещания по проценту загрузки процессора, объему потребленной памяти и загрузки дисковой подсистемы.

Простой тест на устойчивость продукта к DDoS — она прямо пропорциональна использованию семафоров в вашем проекте (посчитайте сколько их у Вас).

## О велосипедах

Где-то вы забыли закрыть хендл, где-то не освободили память (или за Вас это сделала сторонняя библиотека) … в целом проблем у программиста на c (c++ в большей степени) хватает.

Для юземодного приложения, есть AppVerifier, он за утечками памяти не следит, Debug CRT + использование Debug Heap Alloc Map (делает обертки вокруг HeapAlloc …), но прямые вызовы api алокации памяти не видит и не подходит для си, да и бесполезна в случае использования сторонних уже собранных .lib

Для ядра - driver verifier прекрасно следит за утечками памяти, на этапе разработки, однако он ничего не знает о Ваших требованиях к использованию ресурсов. А Static Driver Verifier  проверяет только этап сборки, и не все может поймать.

## О проекте

На текущем этапе это вспомогательный незавершенный проект, для программистов, может быть использован:
  * для контроля утечек, ликов ресурсов (я использовал для длительного мониторинга утечек (несколько суток));
  * для мониторинга лимитов использования ресурсов — на соответствие требованиям;
  * для быстрого поиска виновников утечек.
Весь вывод информации на сейчас идет в windbg или dbgview, хотя учитывая, что проект для программистов - можно допилить к заббиксу или WMI.

![glTF model viewer](docs/hleak.png)

## Использование

Лучше 1 раз увидеть, чем 100 раз услышать — TODO: видео

В виде исходников или уже собранных  библиотек resmon.lib общая для ядра и юзермода + kmode.lib или umode.lib ну и resmonlib.h

В виде resmon_driver.sys — переименовываем его в нужный Вам драйвер, а к имени Вашего драйвера добавляем .check (к примеру veracrypt-x64.sys и veracrypt-x64.sys.check). При выгрузке драйвера в логи попадет статистика ликов если есть. PS: не забываем про тестовый режим или подписываем  resmon_driver.sys

В виде resmon.dll – в своем проекте в виде обертки над main или winmain
```c
int WINAPI wWinMainCheck (HINSTANCE hInstance, HINSTANCE hPrevInstance, wchar_t *lpszCommandLine, int nCmdShow)
{
...
}

int WINAPI wWinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, wchar_t *lpszCommandLine, int nCmdShow)
{
HMODULE dll = LoadLibrary(_T("resmon.dll"));
#pragma warning(push)
#pragma warning(disable: 4229)
void (* install)(void) = (void (*)(void))GetProcAddress(dll, "InstallResMon");
void (* uninstall)(void) = (void (*)(void))GetProcAddress(dll, "UninstallResMon");
void (* logres)(void) = (void (*)(void))GetProcAddress(dll, "LogAllResources");
#pragma warning(pop)

install();

int res = wWinMainCheck (hInstance, hPrevInstance, lpszCommandLine, nCmdShow);

uninstall();
return res;
}
```
при завершении работы приложения в логи попадает статистика ликов.

## Пример

В качестве примера в файле `\tests\kernelmode\main.c` закоментируем `ZwClose(eventHandleZw);`, в дибажной сборке на assert'е найдем где хендл открывали по сохранненому `returnAddress 0xFFFFF8004F4231F5`:

![glTF model viewer](docs/resmontestleak.png)
